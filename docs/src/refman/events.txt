# Events

## API: ALLEGRO_EVENT

An ALLEGRO_EVENT is a union of all builtin event structures, i.e. it is an
object large enough to hold the data of any event type.  All events
have the following fields in common:

    ALLEGRO_EVENT_TYPE          type;
    ALLEGRO_EVENT_SOURCE *      any.source;
    double                      any.timestamp;

By examining the type field you can then access type-specific fields.  The
any.source field tells you which event source generated that particular
event.  The any.timestamp field tells you when the event was generated.  The
time is referenced to the same starting point as al_current_time().

## API: ALLEGRO_EVENT_SOURCE

An event source is any object which can generate events.  Event sources are
usually referred to by distinct types, e.g. ALLEGRO_KEYBOARD*, but can be
casted to ALLEGRO_EVENT_SOURCE* when used in contexts that accept generic
event sources.

Each event is of one of the following types

* ALLEGRO_EVENT_JOYSTICK_AXIS - a joystick axis value changed.
  Fields are: joystick.stick, joystick.axis, joystick.pos (-1.0 to 1.0).

* ALLEGRO_EVENT_JOYSTICK_BUTTON_DOWN - a joystick button was pressed.
  Fields are: joystick.button.
  
* ALLEGRO_EVENT_JOYSTICK_BUTTON_UP - a joystick button was released.
  Fields are: joystick.button.

* ALLEGRO_EVENT_KEY_DOWN - a keyboard key was pressed.
  Fields: keyboard.keycode, keyboard.unichar, keyboard.modifiers.

* ALLEGRO_EVENT_KEY_REPEAT - a typed character auto-repeated.
  Fields: keyboard.keycode (ALLEGRO_KEY_\*), keyboard.unichar (unicode
  character), keyboard.modifiers (ALLEGRO_KEYMOD_\*).

* ALLEGRO_EVENT_KEY_UP - a keyboard key was released.
  Fields: keyboard.keycode.

* ALLEGRO_EVENT_MOUSE_AXES - one or more mouse axis values changed.
  Fields: mouse.x, mouse.y, mouse.z, mouse.dx, mouse.dy, mouse.dz.

* ALLEGRO_EVENT_MOUSE_BUTTON_DOWN - a mouse button was pressed.
  Fields: mouse.x, mouse.y, mouse.z, mouse.button.

* ALLEGRO_EVENT_MOUSE_BUTTON_UP - a mouse button was released.
Fields: mouse.x, mouse.y, mouse.z, mouse.button.

* ALLEGRO_EVENT_MOUSE_ENTER_DISPLAY - the mouse cursor entered a window
  opened by the program.
  Fields: mouse.x, mouse.y, mouse.z.

* ALLEGRO_EVENT_MOUSE_LEAVE_DISPLAY - the mouse cursor leave the boundaries
  of a window opened by the program.
  Fields: mouse.x, mouse.y, mouse.z.

* ALLEGRO_EVENT_TIMER - a timer counter incremented.
  Fields: timer.count.

* ALLEGRO_EVENT_DISPLAY_EXPOSE - The display (or a portion thereof) has
  become visible.
  Fields: display.x, display.y, display.width, display.height

* ALLEGRO_EVENT_DISPLAY_RESIZE - The window has been resized.
  Fields: display.x, display.y, display.width, display.height

* ALLEGRO_EVENT_DISPLAY_CLOSE - The close button of the window has been
  pressed.

* ALLEGRO_EVENT_DISPLAY_LOST - Displays can be lost with some drivers (just
  Direct3D?). This means that rendering is impossible. The device will be
  restored as soon as it is possible. The program should be able to ignore
  this event and continue rendering however it will have no effect.

* ALLEGRO_EVENT_DISPLAY_FOUND - Generated when a lost device is regained.
  Drawing will no longer be a no-op.

* ALLEGRO_EVENT_DISPLAY_SWITCH_OUT - The window is no longer active, that
  is the user might have clicked into another window or "tabbed" away.

* ALLEGRO_EVENT_DISPLAY_SWITCH_IN - The window is the active one again.

## API: al_create_event_queue

Create a new, empty event queue, returning a pointer to object if
successful.  Returns NULL on error.

## API: al_create_user_event_source

Allocate an event source for emitting user events.

## API: al_destroy_event_queue

Destroy the event queue specified.  All event sources currently
registered with the queue will be automatically unregistered before
the queue is destroyed.

## API: al_destroy_user_event_source

Destroy an event source created with [al_create_user_event_source].

## API: al_drop_next_event

Drop the next event packet from the queue.  If the queue is empty,
nothing happens.
Returns true iff an event was dropped.

## API: al_emit_user_event

Emit a user event.
The event source must have been created with [al_create_user_event_source].
Some fields of the event being passed in may be modified.
Returns `false` if the event source isn't registered with any queues,
hence the event wouldn't have been delivered into any queues.

Reference counting will be performed on the event if `dtor` is non-NULL.
When the reference count drops to zero `dtor` will be called with a copy of
the event as an argument.  It should free the resources associated with
the event.  If `dtor` is NULL then reference counting will not be
performed.

You need to call [al_unref_user_event] when you are done with a reference
counted user event that you have gotten from [al_get_next_event],
[al_peek_next_event], [al_wait_for_event], etc.  You may, but do not need
to, call [al_unref_user_event] on non-reference counted user events.

## API: al_event_queue_is_empty

Return true if the event queue specified is currently empty.

## API: al_flush_event_queue

Drops all events, if any, from the queue.

## API: al_get_next_event

Take the next event packet out of the event queue specified, and
copy the contents into RET_EVENT, returning true.  The original
event packet will be removed from the queue.  If the event queue is
empty, return false and the contents of RET_EVENT are unspecified.

## API: al_peek_next_event

Copy the contents of the next event packet in the event queue
specified into RET_EVENT and return true.  The original event
packet will remain at the head of the queue.  If the event queue is
actually empty, this function returns false and the contents of
RET_EVENT are unspecified.

## API: al_register_event_source

Register the event source with the event queue specified.  An
event source may be registered with any number of event queues
simultaneously, or none.  Trying to register an event source with
the same event queue more than once does nothing.

## API: al_unref_user_event

Unreference a user-defined event. This must be called on any user event
that you get from [al_get_next_event], [al_peek_next_event],
[al_wait_for_event], etc. which is reference counted.
This function does nothing if the event is not reference counted.

See also: [al_emit_user_event].

## API: al_unregister_event_source

Unregister an event source with an event queue.  If the event
source is not actually registered with the event queue, nothing
happens.

If the queue had any events in it which originated from the event
source, they will no longer be in the queue after this call.

## API: al_wait_for_event

Wait until the event queue specified is non-empty.  If RET_EVENT
is not NULL, the first event packet in the queue will be copied
into RET_EVENT and removed from the queue.  If RET_EVENT is NULL
the first event packet is left at the head of the queue.

## API: al_wait_for_event_timed

Wait until the event queue specified is non-empty.  If RET_EVENT
is not NULL, the first event packet in the queue will be copied
into RET_EVENT and removed from the queue.  If RET_EVENT is NULL
the first event packet is left at the head of the queue.

TIMEOUT_MSECS determines approximately how many seconds to
wait.  If the call times out, false is returned.  Otherwise true is
returned.

