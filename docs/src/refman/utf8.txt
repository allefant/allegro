% UTF-8 string routines

Here we should give a short overview of Unicode/UCS and in particular UTF-8
encoding.

Explain about code points and relationship to "characters".

Explain that pos parameters are in byte offsets, not code point indices.

Explain about half-open intervals.


# Creating and destroying strings

## API: al_ustr_new

Create a new empty string. It must be freed with [al_ustr_free].


## API: al_ustr_free

Free a previously allocated string.


## API: al_cstr

Get a `char *` pointer to the data in a string.  This pointer will only be
valid while the underlying string is not modified and not destroyed.
The pointer may be passed to functions expecting C-style strings,
with the following caveats:

* ALLEGRO_USTRs are allowed to contain embedded NUL ('\0') bytes.
  That means `al_ustr_size(u)` and `strlen(al_cstr(u))` may not agree.

* An ALLEGRO_USTR may be created in such a way that it is not NUL terminated.
  A string which is dynamically allocated will always be NUL terminated,
  but a string which references the middle of another string or region
  of memory will *not* be NUL terminated.


## API: al_ustr_dup

Return a duplicate copy of a string.
The new string will need to be freed with [al_ustr_free].


## API: al_ustr_dup_substr

Return a new copy of a string, containing its contents in the interval
\[start_pos, end_pos).  The new string will be NUL terminated and will
need to be freed with [al_ustr_free].


# Predefined strings

## API: al_ustr_empty_string

Return a pointer to a static empty string.  The string is read only.


# Creating strings by referencing other data

## API: al_ref_cstr

Create a string that references the storage of a C-style string.  The
information about the string (e.g. its size) is stored in the structure
pointed to by the `info` parameter.  The string will not have any other
storage allocated of its own, so if you allocate the `info` structure on the
stack then no explicit "free" operation is required.

The string is valid until the underlying C string disappears.

Example:

    ALLEGRO_USTR_INFO info;
    ALLEGRO_USTR us = al_ref_cstr(&info, "my string");


## API: al_ref_buffer

Like [al_ref_cstr] but the size of the string data is passed in as a
parameter.  Hence you can use it to reference only part of a string or an
arbitrary region of memory.

The string is valid while the underlying C string is valid.


## API: al_ref_ustr

Create a read-only string that references the storage of another string.
The information about the string (e.g. its size) is stored in the structure
pointed to by the `info` parameter.  The string will not have any other
storage allocated of its own, so if you allocate the `info` structure on the
stack then no explicit "free" operation is required.

The referenced interval is \[start_pos, end_pos).

The string is valid until the underlying string is modified or destroyed.


# Sizes and offsets

## API: al_ustr_size

Return the size of the string in bytes.  This is equal to the number of code
points in the string if the string is empty or contains only 7-bit ASCII
characters.

## API: al_ustr_length

Return the number of code points in the string.

## API: al_ustr_offset

Return the offset (in bytes from the start of the string) of the code point at
the specified index in the string. A zero index parameter will return the first
character of the string. If index is negative, it counts backward from the end
of the string, so an index of -1 will return an offset to the last code point.

If the index is past the end of the string, returns the offset of the end of
the string.

## API: al_ustr_next

Find the byte offset of the next code point in string, beginning at `*pos`.
`*pos` does not have to be at the beginning of a code point.
Returns true on success, then value pointed to by `pos` will be updated to the
found offset.  Otherwise returns false if `*pos` was already at the end of
the string, then `*pos` is unmodified.

This function just looks for an appropriate byte; it doesn't check if found
offset is the beginning of a valid code point.  If you are working with
possibly invalid UTF-8 strings then it could skip over some invalid bytes.

## API: al_ustr_prev

Find the byte offset of the previous code point in string, before `*pos`.
`*pos` does not have to be at the beginning of a code point.
Returns true on success, then value pointed to by `pos` will be updated to the
found offset.  Otherwise returns false if `*pos` was already at the end of
the string, then `*pos` is unmodified.

This function just looks for an appropriate byte; it doesn't check if found
offset is the beginning of a valid code point.  If you are working with
possibly invalid UTF-8 strings then it could skip over some invalid bytes.


# Inserting

## API: al_ustr_insert

Insert `us2` into `us1` beginning at `pos`.  `pos` cannot be less than 0.  If
`pos` is past the end of `us1` then the space between the end of the string
and `pos` will be padded with NUL ('\0') bytes.

Returns true on success, false on error.

## API: al_ustr_insert_cstr

Like [al_ustr_insert] but inserts a C-style string.

## API: al_ustr_insert_chr

Insert a code point into `us` beginning at `pos`.  `pos` cannot be less than 0.
If `pos` is past the end of `us` then the space between the end of the string
and `pos` will be padded with NUL ('\0') bytes.

Returns the number of bytes inserted, or 0 on error.


# Appending

## API: al_ustr_append

Append `us2` to the end of `us1`.

Returns true on success, false on error.

## API: al_ustr_append_cstr

Append C-style string `s` to the end of `us`.

Returns true on success, false on error.

## API: al_ustr_append_chr

Append a code point to the end of `us`.

Returns the number of bytes added, or 0 on error.


# Removing

## API: al_ustr_remove_range

Remove the interval \[start_pos, end_pos) from a string.
`start_pos` and `end_pos` may both be past the end of the string
but cannot be less than 0 (the start of the string).

Returns true on success, false on error.

## API: al_ustr_truncate

Truncate a portion of a string at `start_pos` onwards.
`start_pos` can be past the end of the string (has no effect)
but cannot be less than 0.

Returns true on success, false on error.

## API: al_ustr_ltrim_ws

Remove leading whitespace characters from a string, as defined by the C
function `isspace()`.

Returns true on success, or false if the function was passed an empty string.

## API: al_ustr_rtrim_ws

Remove trailing ("right") whitespace characters from a string, as defined by
the C function `isspace()`.

Returns true on success, or false if the function was passed an empty string.

## API: al_ustr_trim_ws

Remove both leading and trailing whitespace characters from a string.

Returns true on success, or false if the function was passed an empty string.


# Comparing

## API: al_ustr_equal

Return true iff the two strings are equal.  This function is more efficient
than [al_ustr_compare] so is preferable if ordering is not important.


# Low-level UTF-8 routines

## API: al_utf8_width

Returns the number of bytes that would be occupied by the specified code point
when encoded in UTF-8.  This is between 1 and 4 bytes for legal code point
values.  Otherwise returns 0.

## API: al_utf8_encode

Encode the specified code point to UTF-8 into the buffer `s`.  The buffer
must have enough space to hold the encoding, which takes between 1 and 4
bytes.  This routine will refuse to encode code points above 0x10FFFF.

Returns the number of bytes written, which is the as that returned by
[al_utf8_width].


