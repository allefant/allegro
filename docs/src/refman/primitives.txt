%Primitives Addon

# High Level Drawing Routines

## API: al_draw_line

Draws a line segment between two points.

*Parameters:*

* x1, y1, x2, y2 - Start and end points of the line
* color - Color of the line
* thickness - Thickness of the line, pass <= 0 to draw hairline lines

## API: al_draw_triangle

Draws an outlined triangle.

*Parameters:*

* x1, y1, x2, y2, x3, y3 - Three points of the triangle
* color - Color of the triangle
* thickness - Thickness of the lines, pass <= 0 to draw hairline lines

## API: al_draw_filled_triangle

Draws a filled triangle.

*Parameters:*

* x1, y1, x2, y2, x3, y3 - Three points of the triangle
* color - Color of the triangle

## API: al_draw_rectangle

Draws an outlined rectangle.

*Parameters:*

* x1, y1, x2, y2 - Upper left and lower right points of a triangle
* color - Color of the rectangle
* thickness - Thickness of the lines, pass <= 0 to draw hairline lines

## API: al_draw_filled_rectangle

Draws a filled rectangle.

*Parameters:*

* x1, y1, x2, y2 - Upper left and lower right points of a triangle
* color - Color of the rectangle

## API: al_calculate_arc

Calculates an elliptical arc, and sets the vertices in the destination to the calculated positions. If thickness <= 0, then
`num_points` of points are required in the destination, otherwise twice as many are needed.
The destination buffer should consist of regularly spaced (by distance of stride bytes) doublets of floats, corresponding to
x and y coordinates of the vertices.

*Parameters:*

* dest - Pointer to the destination buffer
* stride - Distance (in bytes) between successive pairs of coordinates
* cx, cy - Center of the arc
* rx, ry - Radii of the arc
* start_theta - The initial angle from which the arc is calculated
* delta_theta - Angular span of the arc (pass a negative number to switch direction)
* thickness - Thickness of the arc
* num_points - The number of points to calculate

## API: al_draw_ellipse

Draws an outlined ellipse.

*Parameters:*

* cx, cy - Center of the ellipse
* rx, ry - Radii of the ellipse
* color - Color of the ellipse
* thickness - Thickness of the ellipse, pass <= 0 to draw hairline ellipse

## API: al_draw_filled_ellipse

Draws a filled ellipse.

*Parameters:*

* cx, cy - Center of the ellipse
* rx, ry - Radii of the ellipse
* color - Color of the ellipse

## API: al_draw_circle

Draws an outlined circle.

*Parameters:*

* cx, cy - Center of the circle
* r - Radius of the circle
* color - Color of the circle
* thickness - Thickness of the circle, pass <= 0 to draw hairline circle

## API: al_draw_filled_circle

Draws a filled circle.

*Parameters:*

* cx, cy - Center of the circle
* r - Radius of the circle
* color - Color of the circle

## API: al_draw_arc

Draws an arc.

*Parameters:*

* cx, cy - Center of the arc
* r - Radius of the arc
* color - Color of the arc
* start_theta - The initial angle from which the arc is calculated
* delta_theta - Angular span of the arc (pass a negative number to switch direction)
* thickness - Thickness of the circle, pass <= 0 to draw hairline circle

## API: al_calculate_spline

Calculates a spline given 4 control points. If thickness <= 0, then
`num_segments` of points are required in the destination, otherwise twice as many are needed.
The destination buffer should consist of regularly spaced (by distance of stride bytes) doublets of floats, corresponding to
x and y coordinates of the vertices.

*Parameters:*

* dest - Pointer to the destination buffer
* stride - Distance (in bytes) between successive pairs of coordinates
* points - An array of 4 pairs of coordinates of the 4 control points
* thickness - Thickness of the spline ribbon
* num_segments - The number of points to calculate

## API: al_draw_spline

Draws a spline given 4 control points.

*Parameters:*

* points - An array of 4 pairs of coordinates of the 4 control points
* color - Color of the spline
* thickness - Thickness of the spline, pass <= 0 to draw hairline spline

## API: al_calculate_ribbon

Calculates a ribbon given an array of points. The ribbon will go through all of the passed points. If thickness <= 0, then
`num_segments` of points are required in the destination buffer, otherwise twice as many are needed. 
The destination and the points buffer should consist of regularly spaced doublets of floats, corresponding to
x and y coordinates of the vertices.

*Parameters:*

* dest - Pointer to the destination buffer
* dest_stride - Distance (in bytes) between successive pairs of coordinates in the destination buffer
* points - An array of pairs of coordinates for each point
* points_stride - Distance (in bytes) between successive pairs of coordinates in the points buffer
* thickness - Thickness of the spline ribbon
* num_segments - The number of points to calculate

## API: al_draw_ribbon

Draws a ribbon given given an array of points. The ribbon will go through all of the passed points.

*Parameters:*

* points - An array of pairs of coordinates for each point
* color - Color of the spline
* thickness - Thickness of the spline, pass <= 0 to draw hairline spline

# Low Level Drawing Routines

## API: al_draw_prim

Draws a subset of the passed vertex buffer. It is recommended for the texture to have
its dimensions be a power of 2 for maximum portability with older video cards.

*Parameters:*

* texture - Texture to use, pass 0 to use only shaded primitves
* vtxs - Pointer to an array of vertices
* start, end - Start and end of the subset of the vertex buffer to draw
* type - Primitive type to draw

*Returns:*
Number of primitives drawn

*See Also:*
[ALLEGRO_VERTEX], [ALLEGRO_PRIM_TYPE], [al_draw_indexed_prim]

## API: al_draw_indexed_prim

Draws a subset of the passed vertex buffer. This function uses an index array to specify which vertices to use.
It is recommended for the texture to have its dimensions be a power of 2 for maximum portability with older video cards.

*Parameters:*

* texture - Texture to use, pass 0 to use only shaded primitves
* vtxs - Pointer to an array of vertices
* indices - An array of indices into the vertex buffer
* num_vtx - Number of indices from the indices array you want to draw
* type - Primitive type to draw

*Returns:*
Number of primitives drawn

*See Also:*
[ALLEGRO_VERTEX], [ALLEGRO_PRIM_TYPE], [al_draw_prim]

## API: al_get_allegro_color

Converts an `ALLEGRO_COLOR` into a `ALLEGRO_PRIM_COLOR`.

*Parameters:*

* col - ALLEGRO_COLOR to convert

*Returns:*
Converted ALLEGRO_PRIM_COLOR

*See Also:*
[ALLEGRO_PRIM_COLOR], [al_get_prim_color]

## API: al_get_prim_color

Converts an `ALLEGRO_PRIM_COLOR` into a `ALLEGRO_COLOR`.

*Parameters:*

* col - ALLEGRO_PRIM_COLOR to convert

*Returns:*
Converted ALLEGRO_COLOR

*See Also:*
[ALLEGRO_PRIM_COLOR], [al_get_allegro_color]

# Transformations

## API: al_copy_transform

Makes a copy of a transformation.

*Parameters:*

* src - Source transformation
* dest - Destination transformation

## API: al_use_transform

Sets the transformation to be used for the primitive drawing operations. Every drawing operation after this call will
be transformed using this transformation.

*Parameters:*

* trans - Transformation to use

## API: al_identity_transform

Sets the transformation to be the identity transformation.

*Parameters:*

* trans - Transformation to alter

## API: al_build_transform

Builds a transformation given some parameters. This call is equivalent to calling
the transformations in this order: make identity, scale, rotate, translate. This method is faster, however.

*Parameters:*

* trans - Transformation to alter
* x, y - Translation
* sx, sy - Scale
* theta - Rotation angle

## API: al_translate_transform

Apply a translation to a transformation.

*Parameters:*

* trans - Transformation to alter
* x, y - Translation

## API: al_rotate_transform

Apply a rotation to a transformation.

*Parameters:*

* trans - Transformation to alter
* theta - Rotation angle

## API: al_scale_transform

Apply a scale to a transformation.

*Parameters:*

* trans - Transformation to alter
* sx, sy - Scale

## API: al_transform_vertex

Transform a vertex.

*Parameters:*

* trans - Transformation to use
* vtx - Vertex to transform

## API: al_transform_transform

Transform a transformation.

*Parameters:*

* trans - Transformation to use
* trans2 - Transformation to transform

# Structures and Types

## API: ALLEGRO_PRIM_COLOR

A special structure that defines a color in a way that understandable to both OpenGL and Direct3D backends.
You should never access internal fields, instead using the two conversion functions to convert between it and
[ALLEGRO_COLOR] structure.

*See Also:*
[al_get_allegro_color], [al_get_prim_color]

## API: ALLEGRO_VERTEX

Defines the generic vertex type, with a 2D position, color and texture coordinates
for a single texture.

* x, y, z - Position of the vertex. Use z = 0 if you are only dealing with 2D primitives
* color - `ALLEGRO_PRIM_COLOR` structure
* u, v - Texture coordinates

*See Also:*
[ALLEGRO_PRIM_COLOR]

## API: ALLEGRO_TRANSFORM

Defines the generic transformation type, a 4x4 matrix. 2D transforms use only a small subsection of this matrix,
namely the top left 2x2 matrix, and the right most 2x1 matrix, for a total of 6 values.

# Constants

## API: ALLEGRO_PRIM_TYPE

Enumerates the types of primitves this addon can draw.

* ALLEGRO_PRIM_LINE_LIST - A list of lines, sequential pairs of vertices define disjointed lines
* ALLEGRO_PRIM_LINE_STRIP - A strip of lines, sequential vertices define a strip of lines
* ALLEGRO_PRIM_LINE_LOOP - Like a line strip, except at the end the first and the last vertices are also connected by a line
* ALLEGRO_PRIM_TRIANGLE_LIST - A list of triangles, sequential triplets of vertices define disjointed triangles
* ALLEGRO_PRIM_TRIANGLE_STRIP - A strip of triangles, sequential vertices define a strip of triangles
* ALLEGRO_PRIM_TRIANGLE_FAN - A fan of triangles, all triangles share the first vertex

## API: ALLEGRO_VERTEX_CACHE_SIZE

Defines the size of the transformation vertex cache for the software renderer. If you pass less than this many
vertices to the primitive rendering functions you will get a speed boost. This also defines the size of the cache vertex buffer,
used for the high-level primitives. This corresponds to the maximum number of line segments that will be used to form them.

## API: ALLEGRO_PRIM_QUALITY

Defines the quality of the quadratic primitives. At 10, this roughly corresponds to error < 0.5 pixel.
