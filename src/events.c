/*         ______   ___    ___ 
 *        /\  _  \ /\_ \  /\_ \ 
 *        \ \ \L\ \\//\ \ \//\ \      __     __   _ __   ___ 
 *         \ \  __ \ \ \ \  \ \ \   /'__`\ /'_ `\/\`'__\/ __`\
 *          \ \ \/\ \ \_\ \_ \_\ \_/\  __//\ \L\ \ \ \//\ \L\ \
 *           \ \_\ \_\/\____\/\____\ \____\ \____ \ \_\\ \____/
 *            \/_/\/_/\/____/\/____/\/____/\/___L\ \/_/ \/___/
 *                                           /\____/
 *                                           \_/__/
 *
 *      Event queues.
 *
 *      By Peter Wang.
 *
 *      See readme.txt for copyright information.
 */

/* Title: Event queues
 *
 * An event queue buffers events generated by event sources that were
 * registered with the queue.
 */


#include <string.h>

#include "allegro5/allegro5.h"
#include "allegro5/internal/aintern.h"
#include "allegro5/internal/aintern_dtor.h"
#include "allegro5/internal/aintern_memory.h"
#include "allegro5/internal/aintern_events.h"



struct ALLEGRO_EVENT_QUEUE
{
   _AL_VECTOR sources;
   _AL_MUTEX mutex;
   _AL_COND cond;
   ALLEGRO_EVENT *events_list;
   ALLEGRO_EVENT *free_events_list;
};



/* forward declarations */
static void release_events_of_source(ALLEGRO_EVENT_QUEUE *queue,
   const ALLEGRO_EVENT_SOURCE *source);
static bool do_wait_for_event(ALLEGRO_EVENT_QUEUE *queue,
   ALLEGRO_EVENT *ret_event, ALLEGRO_TIMEOUT *timeout);
static void copy_event(ALLEGRO_EVENT *dest, const ALLEGRO_EVENT *src);
static void release_event(ALLEGRO_EVENT_QUEUE *queue, ALLEGRO_EVENT *event);



/* Function: al_create_event_queue
 *  Create a new, empty event queue, returning a pointer to object if
 *  successful.  Returns NULL on error.
 */
ALLEGRO_EVENT_QUEUE *al_create_event_queue(void)
{
   ALLEGRO_EVENT_QUEUE *queue = _AL_MALLOC(sizeof *queue);

   ASSERT(queue);

   if (queue) {
      _al_vector_init(&queue->sources, sizeof(ALLEGRO_EVENT_SOURCE *));
      _AL_MARK_MUTEX_UNINITED(queue->mutex);
      _al_mutex_init(&queue->mutex);
      _al_cond_init(&queue->cond);
      queue->events_list = NULL;
      queue->free_events_list = NULL;

      _al_register_destructor(queue, (void (*)(void *)) al_destroy_event_queue);
   }

   return queue;
}



/* Function: al_destroy_event_queue
 *  Destroy the event queue specified.  All event sources currently
 *  registered with the queue will be automatically unregistered before
 *  the queue is destroyed.
 */
void al_destroy_event_queue(ALLEGRO_EVENT_QUEUE *queue)
{
   ALLEGRO_EVENT *event;
   ASSERT(queue);

   _al_unregister_destructor(queue);

   /* Unregister any event sources registered with this queue.  */
   while (_al_vector_is_nonempty(&queue->sources)) {
      ALLEGRO_EVENT_SOURCE **slot = _al_vector_ref_back(&queue->sources);
      al_unregister_event_source(queue, *slot);
   }

   ASSERT(_al_vector_is_empty(&queue->sources));
   _al_vector_free(&queue->sources);

   ASSERT(queue->events_list == NULL);

   /* Free all events on free list. */
   while ((event = queue->free_events_list)) {
      queue->free_events_list = event->any._next;
      _AL_FREE(event);
   }

   _al_cond_destroy(&queue->cond);
   _al_mutex_destroy(&queue->mutex);

   _AL_FREE(queue);
}



/* Function: al_register_event_source
 *  Register the event source with the event queue specified.  An
 *  event source may be registered with any number of event queues
 *  simultaneously, or none.  Trying to register an event source with
 *  the same event queue more than once does nothing.
 */
void al_register_event_source(ALLEGRO_EVENT_QUEUE *queue,
   ALLEGRO_EVENT_SOURCE *source)
{
   ALLEGRO_EVENT_SOURCE **slot;
   ASSERT(queue);
   ASSERT(source);

   if (!_al_vector_contains(&queue->sources, &source)) {
      _al_event_source_on_registration_to_queue(source, queue);
      _al_mutex_lock(&queue->mutex);
      slot = _al_vector_alloc_back(&queue->sources);
      *slot = source;
      _al_mutex_unlock(&queue->mutex);
   }
}



/* Function: al_unregister_event_source
 *  Unregister an event source with an event queue.  If the event
 *  source is not actually registered with the event queue, nothing
 *  happens.
 *
 *  If the queue had any events in it which originated from the event
 *  source, they will no longer be in the queue after this call.
 */
void al_unregister_event_source(ALLEGRO_EVENT_QUEUE *queue,
   ALLEGRO_EVENT_SOURCE *source)
{
   bool found;
   ASSERT(queue);
   ASSERT(source);

   /* Remove source from our list.  */
   _al_mutex_lock(&queue->mutex);
   found = _al_vector_find_and_delete(&queue->sources, &source);
   _al_mutex_unlock(&queue->mutex);

   if (found) {
      /* Tell the event source that it was unregistered.  */
      _al_event_source_on_unregistration_from_queue(source, queue);

      /* Drop all the events in the queue that belonged to the source.  */
      release_events_of_source(queue, source);
   }
}



/* release_events_of_source:
 *  Drop all the events in the queue that belong to the source.
 */
static void release_events_of_source(ALLEGRO_EVENT_QUEUE *queue,
   const ALLEGRO_EVENT_SOURCE *source)
{
   ALLEGRO_EVENT *prev = NULL;
   ALLEGRO_EVENT *event;
   ALLEGRO_EVENT *next;

   event = queue->events_list;
   while (event) {
      next = event->any._next;
      if (event->any.source == source) {
         if (prev != NULL)
            prev->any._next = next;
         else
            queue->events_list = next;
         release_event(queue, event);
      }
      else {
         prev = event;
      }
      event = next;
   }
}



/* Function: al_event_queue_is_empty
 *  Return true if the event queue specified is currently empty.
 */
bool al_event_queue_is_empty(ALLEGRO_EVENT_QUEUE *queue)
{
   ASSERT(queue);

   return (queue->events_list == NULL);
}



/* get_next_event_if_any: [primary thread]
 *  Helper function.  It returns a pointer to the next event in the
 *  queue, or NULL.  Optionally the event is removed from the queue.
 *  However, the event is _not released_ (which is the caller's
 *  responsibility).  The event queue must be locked before entering
 *  this function.
 */
static ALLEGRO_EVENT *get_next_event_if_any(ALLEGRO_EVENT_QUEUE *queue,
   bool delete)
{
   ALLEGRO_EVENT *event;

   event = queue->events_list;
   if (event) {
      if (delete) {
         queue->events_list = event->any._next;
      }
   }
   return event;
}



/* get_peek_or_drop_next_event: [primary thread]
 *  Helper function to do the work for al_get_next_event,
 *  al_peek_next_event and al_drop_next_event which are all very
 *  similar.
 */
static bool get_peek_or_drop_next_event(ALLEGRO_EVENT_QUEUE *queue,
   ALLEGRO_EVENT *do_copy, bool do_release)
{
   ALLEGRO_EVENT *next_event;

   _al_mutex_lock(&queue->mutex);

   next_event = get_next_event_if_any(queue, do_release);
   if (next_event) {
      if (do_copy)
         copy_event(do_copy, next_event);
      if (do_release)
         release_event(queue, next_event);
   }

   _al_mutex_unlock(&queue->mutex);

   return (next_event ? true : false);
}



/* Function: al_get_next_event
 *  Take the next event packet out of the event queue specified, and
 *  copy the contents into RET_EVENT, returning true.  The original
 *  event packet will be removed from the queue.  If the event queue is
 *  empty, return false and the contents of RET_EVENT are unspecified.
 */
bool al_get_next_event(ALLEGRO_EVENT_QUEUE *queue, ALLEGRO_EVENT *ret_event)
{
   ASSERT(queue);
   ASSERT(ret_event);

   return get_peek_or_drop_next_event(queue, ret_event, true);
}



/* Function: al_peek_next_event
 *  Copy the contents of the next event packet in the event queue
 *  specified into RET_EVENT and return true.  The original event
 *  packet will remain at the head of the queue.  If the event queue is
 *  actually empty, this function returns false and the contents of
 *  RET_EVENT are unspecified.
 */
bool al_peek_next_event(ALLEGRO_EVENT_QUEUE *queue, ALLEGRO_EVENT *ret_event)
{
   ASSERT(queue);
   ASSERT(ret_event);

   return get_peek_or_drop_next_event(queue, ret_event, false);
}



/* Function: al_drop_next_event
 *  Drop the next event packet from the queue.  If the queue is empty,
 *  nothing happens.
 */
void al_drop_next_event(ALLEGRO_EVENT_QUEUE *queue)
{
   ASSERT(queue);

   get_peek_or_drop_next_event(queue, NULL, true);
}



/* Function: al_flush_event_queue
 *  Drops all events, if any, from the queue.
 */
void al_flush_event_queue(ALLEGRO_EVENT_QUEUE *queue)
{
   ALLEGRO_EVENT *event;

   ASSERT(queue);

   _al_mutex_lock(&queue->mutex);

   while ((event = queue->events_list)) {
      queue->events_list = event->any._next;
      release_event(queue, event);
   }

   _al_mutex_unlock(&queue->mutex);
}



/* [primary thread]
 *
 * Function: al_wait_for_event
 *  Wait until the event queue specified is non-empty.  If RET_EVENT
 *  is not NULL, the first event packet in the queue will be copied
 *  into RET_EVENT and removed from the queue.  If RET_EVENT is NULL
 *  the first event packet is left at the head of the queue.
 */
void al_wait_for_event(ALLEGRO_EVENT_QUEUE *queue, ALLEGRO_EVENT *ret_event)
{
   ALLEGRO_EVENT *next_event = NULL;

   ASSERT(queue);

   _al_mutex_lock(&queue->mutex);
   {
      while (queue->events_list == NULL) {
         _al_cond_wait(&queue->cond, &queue->mutex);
      }

      if (ret_event) {
         next_event = get_next_event_if_any(queue, true);
         ASSERT(next_event);
         copy_event(ret_event, next_event);
         release_event(queue, next_event);
      }
   }

   _al_mutex_unlock(&queue->mutex);
}



/* [primary thread]
 *
 * Function: al_wait_for_event_timed
 *  Wait until the event queue specified is non-empty.  If RET_EVENT
 *  is not NULL, the first event packet in the queue will be copied
 *  into RET_EVENT and removed from the queue.  If RET_EVENT is NULL
 *  the first event packet is left at the head of the queue.
 *
 *  TIMEOUT_MSECS determines approximately how many seconds to
 *  wait.  If the call times out, false is returned.  Otherwise true is
 *  returned.
 */
bool al_wait_for_event_timed(ALLEGRO_EVENT_QUEUE *queue,
   ALLEGRO_EVENT *ret_event, float secs)
{
   ALLEGRO_TIMEOUT timeout;

   ASSERT(queue);
   ASSERT(secs >= 0);

   if (secs < 0.0)
      al_init_timeout(&timeout, 0);
   else
      al_init_timeout(&timeout, secs);

   return do_wait_for_event(queue, ret_event, &timeout);
}



bool al_wait_for_event_until(ALLEGRO_EVENT_QUEUE *queue,
   ALLEGRO_EVENT *ret_event, ALLEGRO_TIMEOUT *timeout)
{
   ASSERT(queue);

   return do_wait_for_event(queue, ret_event, timeout);
}



static bool do_wait_for_event(ALLEGRO_EVENT_QUEUE *queue,
   ALLEGRO_EVENT *ret_event, ALLEGRO_TIMEOUT *timeout)
{
   bool timed_out = false;
   ALLEGRO_EVENT *next_event = NULL;

   _al_mutex_lock(&queue->mutex);
   {
      int result = 0;

      /* Is the queue is non-empty?  If not, block on a condition
       * variable, which will be signaled when an event is placed into
       * the queue.
       */
      while ((queue->events_list == NULL) && (result != -1)) {
         result = _al_cond_timedwait(&queue->cond, &queue->mutex, timeout);
      }

      if (result == -1)
         timed_out = true;
      else if (ret_event) {
         next_event = get_next_event_if_any(queue, true);
         ASSERT(next_event);
         copy_event(ret_event, next_event);
         release_event(queue, next_event);
      }
   }
   _al_mutex_unlock(&queue->mutex);

   if (timed_out)
      return false;

   return true;
}



/*----------------------------------------------------------------------*/



/* make_new_event:
 *  Helper to allocate event structures.
 */
static ALLEGRO_EVENT *make_new_event(void)
{
   ALLEGRO_EVENT *ret;

   ret = _AL_MALLOC(sizeof *ret);
   ASSERT(ret);

   if (ret) {
      ret->any._next = NULL;
   }

   return ret;
}



/* get_unused_event:
 *
 *  The event source must be _locked_ before calling this function.
 *
 *  [runs in background threads]
 */
static ALLEGRO_EVENT *get_unused_event(ALLEGRO_EVENT_QUEUE *queue)
{
   ALLEGRO_EVENT *event;

   event = queue->free_events_list;
   if (!event) {
      event = make_new_event();
   }
   else {
      queue->free_events_list = event->any._next;
   }

   return event;
}



/* Internal function: _al_event_queue_push_event
 *  Event sources call this function when they have something to add to
 *  the queue.  If a queue cannot accept the event, the event's
 *  refcount will not be incremented.
 *
 *  If no event queues can accept the event, the event should be
 *  returned to the event source's list of recyclable events.
 */
void _al_event_queue_push_event(ALLEGRO_EVENT_QUEUE *queue,
   const ALLEGRO_EVENT *orig_event)
{
   ALLEGRO_EVENT *event;
   ALLEGRO_EVENT *iter;
   ASSERT(queue);
   ASSERT(orig_event);

   _al_mutex_lock(&queue->mutex);
   {
      /* XXX inefficient */
      event = get_unused_event(queue);
      if (event) {
         copy_event(event, orig_event);

         if (queue->events_list == NULL) {
            queue->events_list = event;
         }
         else {
            iter = queue->events_list;
            while (iter->any._next != NULL) {
               iter = iter->any._next;
            }
            iter->any._next = event;
         }

         /* Wake up threads that are waiting for an event to be placed in
          * the queue.
          */
         _al_cond_broadcast(&queue->cond);
      }
   }
   _al_mutex_unlock(&queue->mutex);
}



/* copy_event:
 *  Copies the contents of the event SRC to DEST.
 */
static void copy_event(ALLEGRO_EVENT *dest, const ALLEGRO_EVENT *src)
{
   ASSERT(dest);
   ASSERT(src);

   *dest = *src;

   dest->any._next = NULL;
}



/* release_event:
 *  Return an event to the queue's free list.
 *  The event queue must be locked before entering this function.
 *  The event must not be on the queue.
 */
static void release_event(ALLEGRO_EVENT_QUEUE *queue, ALLEGRO_EVENT *event)
{
   event->any._next = queue->free_events_list;
   queue->free_events_list = event;
}



/*
 * Local Variables:
 * c-basic-offset: 3
 * indent-tabs-mode: nil
 * End:
 */
/* vim: set sts=3 sw=3 et: */
